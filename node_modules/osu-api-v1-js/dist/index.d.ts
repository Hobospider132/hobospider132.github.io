import { User } from "./user.js";
import { Score, ScoreWithBeatmapid, ScoreWithBeatmapidReplayavailablePp, ScoreWithReplayavailablePp } from "./score.js";
import { Beatmap, Categories, Genres, Languages } from "./beatmap.js";
import { Match, MultiplayerModes, WinConditions } from "./match.js";
import { Mods } from "./mods.js";
import { Replay } from "./replay.js";
import { Gamemodes, getLength, getURL } from "./misc.js";
export { Gamemodes, User, Score, ScoreWithBeatmapid, ScoreWithBeatmapidReplayavailablePp, ScoreWithReplayavailablePp, Mods, Replay };
export { Beatmap, Categories, Genres, Languages };
export { Match, MultiplayerModes, WinConditions };
export { getLength, getURL };
/**
 * If the `API` throws an error, it should always be an `APIError`!
 */
export declare class APIError {
    message: string;
    server: string;
    endpoint: string;
    parameters: string;
    /**
     * @param message The reason why things didn't go as expected
     * @param server The server to which the request was sent
     * @param endpoint The type of resource that was requested from the server
     * @param parameters The filters that were used to specify what resource was wanted
     */
    constructor(message: string, server: string, endpoint: string, parameters: string);
}
/**
 * Create an object of this class to get started!
 */
export declare class API {
    key: string;
    verbose: "none" | "errors" | "all";
    server: string;
    /**
     * @param key Your API key, which you can get at https://osu.ppy.sh/p/api
     * @param verbose (default `none`) Which events should be logged
     * @param server (default `https://osu.ppy.sh/api/`) The server where the requests should be sent to
     */
    constructor(key: string, verbose?: "none" | "errors" | "all", server?: string);
    /**
     * Use this instead of `console.log` to log any information
     * @param is_error Is the information an error?
     * @param to_log Whatever you would put between the parentheses of `console.log()`
     */
    private log;
    /**
     * @param endpoint Basically the endpoint, what comes in the URL after `api/`
     * @param parameters The things to specify in the request, such as the beatmap_id when looking for a beatmap
     * @param number_try How many attempts there's been to get the data
     * @returns A Promise with the API's response
     */
    private request;
    /**
     * @param gamemode The `User`'s `Gamemode`
     * @param user An Object with either a `user_id` or a `username` (ignores `username` if `user_id` is specified)
     * @returns A Promise with a `User` found with the search
     */
    getUser(gamemode: Gamemodes, user: {
        user_id?: User["user_id"];
        username?: User["username"];
    } | User): Promise<User>;
    /**
     * @param limit The maximum number of Scores to get, **cannot exceed 100**
     * @param gamemode The `User`'s `Gamemode`
     * @param user An Object with either a `user_id` or a `username` (`user_id` is preferred)
     * @returns A Promise with an array of `Scores` set by the `User` within the last 24 hours in a specific `Gamemode`
     */
    getUserBestScores(limit: number, gamemode: Gamemodes, user: {
        user_id?: User["user_id"];
        username?: User["username"];
    } | User): Promise<ScoreWithBeatmapidReplayavailablePp[]>;
    /**
     * @param limit The maximum number of Scores to get, **cannot exceed 100**
     * @param gamemode The `User`'s `Gamemode`
     * @param user An Object with either a `user_id` or a `username` (`user_id` is preferred)
     * @returns A Promise with an array of `Scores` set by the `User` within the last 24 hours in a specific `Gamemode`
     */
    getUserRecentScores(limit: number, gamemode: Gamemodes, user: {
        user_id?: User["user_id"];
        username?: User["username"];
    } | User): Promise<ScoreWithBeatmapid[]>;
    /**
     * Look for and get a singular `Beatmap` with this!
     * @param beatmap An Object with the ID of the difficulty/`Beatmap` of the beatmapset
     * @param mods An array of `Mods` to apply, defaults to an empty array
     * @param gamemode The gamemode the beatmap is in (useful if you wanna convert, for example, an osu! map to taiko)
     * @returns A Promise with a `Beatmap`
     */
    getBeatmap(beatmap: {
        beatmap_id: Beatmap["beatmap_id"];
    } | Beatmap, mods?: Mods[], gamemode?: Gamemodes): Promise<Beatmap>;
    /**
     * Look for and get `Beatmap`s with this! Throws an `APIError` if the array would be empty
     * @param limit The maximum number of `Beatmap`s there should be in the array, **cannot exceed 500**
     * @param gamemode Filter in the beatmaps by the gamemode (unless "all"), but if `allow_converts` then instead convert if possible the beatmaps to that gamemode
     * @param beatmap Will look for its `beatmapset_id` (if undefined, its `beatmap_id` (if undefined, its `file_md5`))
     * @param mods An array of `Mods` to apply, defaults to an empty array
     * @param set_owner The `User` that owns the beatmapset
     * @param since Filters out any `Beatmap` of `Category < 0`, and any `Beatmap` with an `approved_date` older than what's given
     */
    getBeatmaps(limit: number, gamemode: {
        gamemode: Gamemodes | "all";
        allow_converts?: boolean;
    }, beatmap?: {
        beatmapset_id?: Beatmap["beatmapset_id"];
        beatmap_id?: Beatmap["beatmap_id"];
        file_md5?: Beatmap["file_md5"];
    } | Beatmap, mods?: Mods[], set_owner?: {
        user_id?: number;
        username?: string;
    } | User, since?: Date): Promise<Beatmap[]>;
    /**
     * @param limit The maximum number of `Scores` to get, **cannot exceed 100**
     * @param gamemode A number representing the `Scores`' `Gamemode`
     * @param beatmap An Object with the ID of the difficulty/`Beatmap` of the beatmapset
     * @param user The `Scores`' user, which is an Object with either a `user_id` or a `username`
     * @param mods An array of `Mods` to apply, defaults to an empty array
     * @returns A Promise with an array of `Scores` set on a beatmap
     */
    getBeatmapScores(limit: number, gamemode: Gamemodes, beatmap: {
        beatmap_id: Beatmap["beatmap_id"];
    } | Beatmap, user?: {
        user_id?: User["user_id"];
        username?: User["username"];
    } | User, mods?: Mods[]): Promise<ScoreWithReplayavailablePp[]>;
    /**
     * @param id The ID of the `Match`
     * @returns A Promise with a `Match`
     * @remarks If the API's server is set to `https://ripple.moe/api`, `getMatch` might not work as it's currently unsupported by Ripple,
     * see https://docs.ripple.moe/docs/api/peppy
     */
    getMatch(id: number): Promise<Match>;
    /**
     * Specify the gamemode the score was set in, then say if you know the id of the `Score` OR if you know the score's `User`, `Beatmap`, and `Mods`
     * @param gamemode A number representing the `Gamemode` the `Score` was set in
     * @param replay An Object that contains a score with an id, or an Object that specifies info about the score (`User`, `Beatmap`, and `Mods`)
     * @returns If possible, a `Replay` of that `Score`
     * @remarks If the API's server is set to `https://ripple.moe/api`, `getReplay` might not work as it's currently unsupported by Ripple,
     * see https://docs.ripple.moe/docs/api/peppy
     */
    getReplay(gamemode: Gamemodes, replay: {
        score_id?: number;
        search?: {
            user: {
                user_id?: User["user_id"];
                username?: User["username"];
            } | User;
            beatmap: {
                beatmap_id: Beatmap["beatmap_id"];
            } | Beatmap;
            mods: Mods[];
        };
    }): Promise<Replay>;
}
