/**
 * It's a bitwise enum, works in such a way that `1` would be `NOFAIL` while `10` would be `HIDDEN + EASY`
 * https://github.com/ppy/osu-api/wiki#mods
 */
export var Mods;
(function (Mods) {
    Mods[Mods["NONE"] = 0] = "NONE";
    Mods[Mods["NOFAIL"] = 1] = "NOFAIL";
    Mods[Mods["EASY"] = 2] = "EASY";
    Mods[Mods["TOUCHDEVICE"] = 4] = "TOUCHDEVICE";
    Mods[Mods["HIDDEN"] = 8] = "HIDDEN";
    Mods[Mods["HARDROCK"] = 16] = "HARDROCK";
    Mods[Mods["SUDDENDEATH"] = 32] = "SUDDENDEATH";
    Mods[Mods["DOUBLETIME"] = 64] = "DOUBLETIME";
    Mods[Mods["RELAX"] = 128] = "RELAX";
    Mods[Mods["HALFTIME"] = 256] = "HALFTIME";
    /**
     * @remarks From osu!api wiki: Only set along with DoubleTime. i.e: NC only gives 576
     */
    Mods[Mods["NIGHTCORE"] = 512] = "NIGHTCORE";
    Mods[Mods["FLASHLIGHT"] = 1024] = "FLASHLIGHT";
    Mods[Mods["AUTOPLAY"] = 2048] = "AUTOPLAY";
    Mods[Mods["SPUNOUT"] = 4096] = "SPUNOUT";
    /**
     * It's called `Relax2` in the osu!api wiki
     */
    Mods[Mods["AUTOPILOT"] = 8192] = "AUTOPILOT";
    /**
     * @remarks From osu!api wiki: Only set along with SuddenDeath. i.e: PF only gives 16416
     */
    Mods[Mods["PERFECT"] = 16384] = "PERFECT";
    Mods[Mods["KEY4"] = 32768] = "KEY4";
    Mods[Mods["KEY5"] = 65536] = "KEY5";
    Mods[Mods["KEY6"] = 131072] = "KEY6";
    Mods[Mods["KEY7"] = 262144] = "KEY7";
    Mods[Mods["KEY8"] = 524288] = "KEY8";
    Mods[Mods["FADEIN"] = 1048576] = "FADEIN";
    Mods[Mods["RANDOM"] = 2097152] = "RANDOM";
    Mods[Mods["CINEMA"] = 4194304] = "CINEMA";
    Mods[Mods["TARGET"] = 8388608] = "TARGET";
    Mods[Mods["KEY9"] = 16777216] = "KEY9";
    Mods[Mods["KEYCOOP"] = 33554432] = "KEYCOOP";
    Mods[Mods["KEY1"] = 67108864] = "KEY1";
    Mods[Mods["KEY3"] = 134217728] = "KEY3";
    Mods[Mods["KEY2"] = 268435456] = "KEY2";
    Mods[Mods["SCOREV2"] = 536870912] = "SCOREV2";
    Mods[Mods["MIRROR"] = 1073741824] = "MIRROR";
})(Mods || (Mods = {}));
(function (Mods) {
    /**
     * API returns the SR (and pp stuff) of a Beatmap as 0/null if any of those mods are included
     * @remarks `Mods.removeUnsupported` takes care of automatically removing/replacing them
     */
    Mods.unsupported = [
        Mods.NOFAIL, Mods.HIDDEN, Mods.SPUNOUT, Mods.FADEIN, Mods.NIGHTCORE,
        Mods.SUDDENDEATH, Mods.PERFECT,
        Mods.RELAX, Mods.AUTOPLAY, Mods.AUTOPILOT, Mods.CINEMA,
        Mods.RANDOM, Mods.TARGET, Mods.SCOREV2, Mods.MIRROR,
        Mods.KEY1, Mods.KEY2, Mods.KEY3, Mods.KEY4, Mods.KEY5, Mods.KEY6, Mods.KEY7, Mods.KEY8, Mods.KEY9, Mods.KEYCOOP,
    ];
    /**
     * This function is called automatically for `getBeatmap` and `getBeatmaps`, you may use it yourself if it is necessary for anything else
     * @param mods An array of `Mods` from which the so-called "unsupported mods" will be removed
     * @returns `mods` without the unsupported mods, and with `Mods.DOUBLETIME` if `Mods.NIGHTCORE` was in there
     */
    function removeUnsupported(mods) {
        if (mods.includes(Mods.NIGHTCORE) === true && mods.includes(Mods.DOUBLETIME) === false) {
            mods.push(Mods.DOUBLETIME);
        }
        Mods.unsupported.forEach((m) => {
            while (mods.indexOf(m) !== -1) {
                mods.splice(mods.indexOf(m), 1);
            }
        });
        return mods;
    }
    Mods.removeUnsupported = removeUnsupported;
    /**
     * This function turns a number that represents `Mods` into an array of `Mods[]`, which makes it useful to translate responses from the API server
     * @param mods The number representing the `Mods`, usually from the response received after a request to the API server
     * @returns An array with all the appropriate `Mods`
     */
    function bitsToArray(mods) {
        const arr = [];
        for (let bit = 1; bit != 0; bit <<= 1) {
            if ((mods & bit) != 0 && bit in Mods) {
                arr.push(bit);
            }
        }
        return arr;
    }
    Mods.bitsToArray = bitsToArray;
    /**
     * This function turns an array of `Mods` into a number that the API server can understand
     * @remarks One useful thing about it is the distinction made between `[]` (lack of mods) and `[Mods.NOMOD]`; specifying the nomod mod can alter requests
     * @param mods An array of `Mods` that will be turned into bits
     * @returns A number representing the `Mods`, or `null` if the array is empty
     */
    function arrayToBits(mods) {
        return !mods.length ? null : mods.reduce((a, b) => a + b);
    }
    Mods.arrayToBits = arrayToBits;
    /**
     * This function returns a Beatmap with properties adjusted to the chosen Mods without making a request to the servers
     *
     * The properties are namely:
     * `total_length`, `hit_length`, `bpm`, `diff_size`, `diff_approach`, `diff_overall`, `diff_drain`
     * @remarks Note that this function doesn't adjust `diff_aim`, `diff_speed` or `difficultyrating`!
     * Making a request using `getBeatmap()` adjusts everything, if you need to adjust any of these three properties
     * @param beatmap The Beatmap to adapt
     * @param mods The Mods to which the Beatmap will be adapted
     * @returns The Beatmap, but adjusted to the Mods
     */
    Mods.adjustBeatmapStats = (beatmap, mods) => {
        beatmap = Object.assign({}, beatmap); // Do not change the original Beatmap outside this function
        if (!Array.isArray(mods)) {
            mods = bitsToArray(mods);
        }
        const convertARtoMS = (ar) => {
            ar *= 10;
            let ms = 1800; // AR 0's ms
            for (let i = 0; i < ar; i++) {
                ms -= i >= 50 ? 15 : 12;
            }
            return ms;
        };
        if (mods.includes(Mods.EASY)) {
            beatmap.diff_size /= 2;
            beatmap.diff_approach /= 2;
            beatmap.diff_overall /= 2;
            beatmap.diff_drain /= 2;
        }
        if (mods.includes(Mods.HARDROCK)) {
            beatmap.diff_size = Math.min(10, beatmap.diff_size * 1.3);
            beatmap.diff_approach = Math.min(10, beatmap.diff_approach * 1.4);
            beatmap.diff_overall = Math.min(10, beatmap.diff_overall * 1.4);
            beatmap.diff_drain = Math.min(10, beatmap.diff_drain * 1.4);
        }
        if (mods.includes(Mods.DOUBLETIME) || mods.includes(Mods.NIGHTCORE)) {
            beatmap.total_length /= 1.5;
            beatmap.hit_length /= 1.5;
            beatmap.bpm *= 1.5;
            beatmap.diff_approach = (1950 - (convertARtoMS(beatmap.diff_approach) / 1.5)) / 150;
            beatmap.diff_overall = (80 - ((80 - 6 * beatmap.diff_overall) / 1.5)) / 6;
        }
        if (mods.includes(Mods.HALFTIME)) {
            beatmap.total_length /= 0.75;
            beatmap.hit_length /= 0.75;
            beatmap.bpm *= 0.75;
            beatmap.diff_approach = beatmap.diff_approach > 7 ?
                (1950 - (convertARtoMS(beatmap.diff_approach) / 0.75)) / 150 :
                (1800 - (convertARtoMS(beatmap.diff_approach) / 0.75)) / 120; // :skull:
            beatmap.diff_overall = (80 - ((80 - 6 * beatmap.diff_overall) / 0.75)) / 6;
        }
        return beatmap;
    };
})(Mods || (Mods = {}));
